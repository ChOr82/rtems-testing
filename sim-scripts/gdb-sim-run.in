#! /bin/sh
#
#  Framework script tailored for the @CPU@/@BSP@
#
#  NOTE: If the does not have the name of a specific CPU/BSP pair, then
#        this is the source file.  If it does have specific CPU/BSP pair,
#        then this is generated output and should NOT be edited.
#  
#  $Id$
#

trap "test_exit 1" 1 2 3 13 14 15

test_exit()
{
  exit_code=$1
  exit $exit_code
}


progname=${0##*/}        # fast basename hack for ksh, bash

USAGE=\
"usage: $progname [ -opts ] test [ test ... ]
	-v	   -- verbose
	-c	   -- enabled coverage (default=no)
	-g	   -- generate device tree and exit (default=no)
	-i	   -- interactive (default=no time limit)
	-s	   -- force System V IPC support (default=no)
        -l limit   -- specify time limit (default is 'BSP dependent')

System V IPC and Coverage are not supported by all BSPs or simulators.

When you generate a device tree and exit, remember to specify an executable.
Otherwise, the script won't know what to generate it for.
"

#   log an error to stderr
prerr()
{
    echo "$*" >&2
}

fatal() {
    [ "$1" ] && prerr $*
    prerr "$USAGE"
    exit 1
}

warn() {
    [ "$1" ] && prerr $*
}

#
# process the options
#
# defaults for getopt vars
#

coverage="no"
verbose="no"
limit="not_set"
interactive="no"
use_sysv_ipc="no"
generate_tree_and_exit="no"

while getopts vgil:s OPT
do
 case "$OPT" in
   v) verbose="yes";;
   c) coverage="yes";;
   g) generate_tree_and_exit="yes" ;;
   i) interactive="yes";;
   l) limit="$OPTARG";;
   s) use_sysv_ipc="yes";;
   *) fatal;;
 esac
done

shiftcount=`expr $OPTIND - 1`
shift $shiftcount

if [ ${interactive} = "yes" ] ; then
  limit=0
fi

args=$*

### Set BSP defaults.  If BSP does not have default, it will override
bspRunFatal="no"
bspGeneratesDeviceTree="no"
bspSupportsSystemVIPC="no"

rtemsVersion=`echo ${progname} | sed -e 's/@BSP@-//' -e 's/-gdb//'`
RUN=@CPU_TARGET@-rtems${rtemsVersion}-run

###################################################################
###################################################################
###################################################################
##INSERT BSP SUPPORT HERE
###################################################################
###################################################################
###################################################################

if [ ${bspSupportsSystemVIPC} = "no" -a ${use_sysv_ipc} = "yes"  ]; then
  echo "Simulator does not support System V IPC."
  exit 1
fi

## These are faults any BSP may generate.  They are common to RTEMS.
checkGenericFaults()
{
  logfile=$1

  for pattern in  \
     "^.*EXECUTIVE SHUTDOWN" \
     "^\*\*\* END OF " \
     "Suspending faulting task" \
     "assertion failed"
  do
    grep "${pattern}" ${logfile} >/dev/null
    if [ $? -eq 0 ] ; then
      return 1
    fi
  done
  return 0
}

runtest()
{
  testname=${1}
  testtype=${2}
  max_run_time=${3}
  if [ ${max_run_time} -eq 0 ] ; then
    #echo run ${testname} forever
    ${runBSP} `runARGS ${testname}`
    return
  fi

  #echo run ${testname} for maximum ${max_run_time} seconds
  logfile=${testname}.tmp
  ${runBSP} `runARGS ${testname}` >${logfile} 2>&1 &
  pid=$!

  # Make sure it won't run forever...
  millilimit=`expr ${max_run_time} \* 1000`
  milliseconds=0
  while :
  do
    # sleep 10ms at a time waiting for job to finish or timer to expire
    # if job has exited, then we exit, too.
    usleep 10000  # ten milliseconds
    milliseconds=`expr ${milliseconds} + 10`
    kill -0 $pid 2> /dev/null
    running=$?
    if [ $running -eq 0 ] ; then
      if [ ${milliseconds} -ge ${millilimit} ]; then
        kill -9 $pid 2> /dev/null
        cat ${logfile}
        echo "${testname} killed after running ${max_run_time} seconds"
        break
      fi
      if [ ! -r ${logfile} ] ; then
        continue
      fi
      checkBSPFaults ${logfile} >/dev/null 2>&1
      bspFaults=$?
      checkGenericFaults ${logfile} >/dev/null 2>&1
      genericFaults=$?
      if [ ${bspFaults} -ne 0 -o ${genericFaults} -ne 0 ] ; then
        kill -9 ${pid} >/dev/null 2>&1
        cat ${logfile}
        echo Ran in ${milliseconds} milliseconds
        break
      fi
  else
    # done normally
    cat ${logfile}
    echo "${testname} ran in ${milliseconds} milliseconds"
    break
  fi
  done
  kill -9 $pid >/dev/null 2>&1
}

if [ "X${args}" = "X" ] ; then
  echo no tests to run
  exit 1
fi

## Now run the tests
for toRun in $args
do
  baseToRun=`basename ${toRun}`
  case ${baseToRun} in
    *-node*) testtype="mp"     ;;
    *fatal*) testtype="fatal"  ;;
    *)       testtype="single" ;;
  esac

  ## Some BSPs must generate device trees to provide to the simulator
  if [ ${bspGeneratesDeviceTree} = "yes" ] ; then
    bspGenerateDeviceTree ${baseToRun}
    if [ ${generate_tree_and_exit} = "yes" ] ; then
      echo "Device tree generated and in ${bspTreeFile}"
      exit 0
    fi 
  fi

  if [ ${interactive} = "yes" ] ; then
    runtest ${toRun} ${testtype} 0
    continue
  fi

  if [ ${limit} = "not_set" ] ; then
    bspLimit ${toRun}
    limit=$?
  fi
  if [ ${testtype} = "fatal" -a ${bspRunFatal} = "no" ] ; then
    warn "Skipping fatal error test ${toRun}"
    continue
  fi

  ## If the test is known to be interactive or locks up and we are
  ## in batch mode, skip it.
  case ${toRun} in
    monitor* | termios* | fileio*)
        warn "Skipping $tname; it is interactive"
        continue
        ;;
    *-node2*)
        fatal "MP tests not supported"
        warn "Skipping $tname; 'runtest' runs both nodes when for *-node1"
        continue;;
    *-node1*)
      warn "Running both nodes associated with $tname"
      ;;
    minimum*|spfatal|termio*)
      warn "Skipping $tname; it locks up or takes a VERY long time to run"
      continue
      ;;
   esac

  test ${verbose} = "yes" && runtest ${toRun} ${testtype} ${limit}
  runtest ${toRun} ${testtype} ${limit}

  if [ ${bspGeneratesDeviceTree} = "yes" ] ; then
    rm -f ${bspTreeFile}
  fi
done

exit $?

