eventsurrender.c:81
Interrupt Synchronization
This is executed when events are sent to the currently executing thread
while it is in the process of blocking.  I think sp39 or sp41 relates to
this but may not be hitting the correct combination of timed out or Any/All.
+++

eventsurrender.c:82
Interrupt Synchronization
This is somehow related to eventsurrender.c:81 but the range is
disconnected and I do not see why with certainty.  This could be
when a timeout occurs while we are blocking on an event receive.
+++

eventtimeout.c:78
Interrupt Synchronization
This is a timeout while blocking waiting for an event receive with timeout.
+++

ratemontimeout.c:61
Simple Test Case
period times out but thread is blocked on another period?
+++

taskinitusers.c:68
Simple Test Case
Errors which require overriding confdefs and/or multiple init tasks (2 cases?)
+++

ratemonperiod.c:310
Interrupt Synchronization
period must expire while attempting to block
+++

watchdog.inl:129
Interrupt Synchronization

period expires while blocking (ratemontimeout.c:66)
+++

timerreset.c:60
Simple Test Case
new error case
+++

timerserverfireafter.c:80
Interrupt Synchronization
timer must be inserted by an ISR while we are inserting it
+++

semcreate.c:163
Simple Test Case
need to create a semaphore that is RTEMS_PRIORITY_CEILING
+++

coremsgflushwait.c:65
Dead Code?
This appears to be dead code and the routine may be able to be removed.
Verify this is the case and remove it.
+++

coremsgsubmit.c:153
Simple Test Case
Send message to full queue from ISR.  Must be done from POSIX API since you
cannot block on send with Classic API.
+++

coremsgsubmit.c:179
Simple Test Case or Dead Code?
This is the error path for a NULL message pointer.  This may not be able
to be reached from the APIs and if so, should be conditionalized as DEBUG.
If it can be reached from the APIs, then it is a simple test case.
+++

coremutex.inl:171
Simple Test Case
pri ceiling, acquire when pri = ceiling
+++

coremutexsurrender.c:88
Simple Test Case or Code Restructuring
This is a switch which has two cases marked as not able to be hit. This
documentation needs to be verified and if true, restructured to represent
this.  The cases that are not executed need to be turned into a
conditionalized debug assertion.
+++

coremutexsurrender.c:178
Simple Test Case
I have trouble believing there is no simple priority ceiling mutex test
which locks raises priority and then releases and lowers priority but this
case sure looks like that.  Or it is a case where the thread's priority
is equal to the ceiling and the branch is taken.  Hard to read SPARC assembly.
I am leaning to the equal case.
+++

corerwlockrelease.c:53
Simple Test Case
This is a case where you are releasing an RWLock that is already released.
So this should be a very simple test case.
+++

corespinlockwait.c:75
Simple Test Case (or unreachable SuperCore)
This is either a simple test case or a case where the SuperCore includes
functionality which is not promoted out yet via an API.  If this is code
which is not available via the API yet, then it should be conditionalized
and disabled.  This is the timeout case if that is available via an API.
+++

semflush.c:82
Simple Test Case
need to flush a NOT counting semaphore
+++

regionresizesegment.c:83
Simple Test Case
need a test (9 instructions)
+++

debug.c:63
Simple Test Case
need a test
+++

heapgetinfo.c:70
Simple Test Case
The heap is corrupted.  The block's size does not match the next block's
previous size backwards link.  This may make sense to add to the
Heap Walk test.
+++

objectidtoname.c:78
Simple Test Case
I find it hard to believe that this is not already covered but the code
appears to be the exit path for the successful lookup of an id to return
the object's name. Verify the lack of a test case and add one.  If there
is a test case that would appear to cover this, investigate.
+++

objectgetinfo.c:36
Dead Code?
This appears to be a case where a number which should be unsigned
(and maybe isn't) is being checked for being negative.  The method
being called probably should be changed to return an unsigned int
and the < 0 comparison removed.
+++

objectnametoid.c:75
Simple Test Case
With POSIX configured, look up an invalid name.  There should be no
Classic API objects.
+++

objectnametoidstring.c:66
Simple Test Case (or Dead Code)
This is checking for a NULL name string.  This error may be caught at
the API level.  Or is may simply not be tested.
+++

pheapgetinfo.c:40
Simple Test Case
This appears to be the exit path for all errors in this routine.  Obviously
there are no tests for errors.
+++

ioregisterdriver.c:61
Simple Test Case
documented (not implemented) in sp40.  Fill up the driver table and
register another driver.
+++


ioregisterdriver.c:71
Simple Test Case
documented (not implemented) in sp40.  Fill up the driver table and
register another driver.  All of the cases in this file are probably
related and will take attention when working on them to be sure I
have explained them correctly.  The assembly is just hard to follow.
+++


ioregisterdriver.c:84
Simple Test Case
if reachable
+++

coremsgbroadcast.c:86
Simple Test Case
Successful but no tasks waiting
+++

corespinlockrelease.c:59
Simple Test Case
need a case for unlock when not holder
+++

corespinlockwait.c:67
Simple Test Case
need a case for not willing to wait
+++

coretodmsecstoticks.c:23
Simple Test Case
Need to disable inline/macro and test body
+++

dpmemcreate.c:87
Simple Test Case
need invalid address of return id
+++

timerfireafter.c:76
Interrupt Synchronization
timer must be inserted or state altered by ISR
+++

thread.inl:230
SHOULD BE COVERED
sp39 should cover this .. timeout while blocking (eventtimeout.c:71)
+++

thread.inl:47
Simple Test Case
(sys state trickery) shutdown while in shutdown statek
+++

threadcreateidle.c:59
Simple Test Case
This appears to be a case where the IDLE task stack size is explicitly
configured to be less than the minimum stack size and has to be increased.
It should be possible to make a minor configuration change to an existing
test to cover this one.
+++

threadget.c:88
Simple Test Case
This will require adding a POSIX test where only Classic API tasks are
configured and what should be the valid Id of a POSIX thread is passed
to any thread/task routine.
+++

threadinitialize.c:91
Simple Test Case and Code Should be Optional for Tiny/RTEMS
This is for the case where the BSP/application is configured to provide
their own stack allocation routines.  But this code is rarely used so
(1) there needs to be a test and (2) the code supporting this capability
needs to be inside a conditional which can be disabled for Tiny/RTEMS.
+++

threadinitialize.c:148
Medium Test Case
The allocation of the user extension data area must fail.  The failure should
occur during the create case of an Floating Point enabled task.

Since the stack is allocated first, it should be possible to have a test
with a fair (16-32?) number of user extensions configured and then
create a thread with increasingly larger stack until this case is hit.
+++

threadinitialize.c:188
Simple Test Case
There must not be a thread/task created
with THREAD_CPU_BUDGET_ALGORITHM_EXHAUST_TIMESLICE.
+++

threadinitialize.c:233
Simple Test Case
A user extension must return an error for the create case of an Floating
Point enabled task.  
+++

threadreset.c:63
Simple Test Case
This is a case where a task is restarted with its per task watchdog
timer active. This probably can be hit by having a task do a long
wake after and another thread restart it.
+++

regionextend.c:75
Simple Test Case, Possible Restructuring
possibly dead code from switch, change to if's
+++

corebarrierwait.c:64
Simple Test Case
This looks like a simple test case of being a automatically released 
barrier and being the Nth task to block so tripping the automatic release.
+++

mutexget.c:76
Simple Test Case (if correct)
mutex lock with auto initialization of mutex
+++

prwlocktimedwrlock.c:89
Simple Test Case
Need to deal with timeout cases (past and future)
+++

prwlocktimedrdlock.c:90
Simple Test Case
Need to deal with timeout cases (past and future)
+++

pthreadcreate.c:130
Simple Test Case
bad scheduling policy in switch
+++

pthreadsetschedparam.c:53
Simple Test Case
bad policy case
+++

pthreadsetschedparam.c:70
Simple Test Case
SCHED_SPORADIC with bad replenish period
+++

chain.inl:300
Simple Test Case
_POSIX_signals_Clear_signals:71 chain get when empty
+++

pthreadkill.c:69
Simple Test Case
psignal to running thread from ISR
+++

threadqenqueuepriority.c:139
Interrupt Synchronization
restart insertion search
+++

threadqenqueuepriority.c:189
Simple Test Case
need sp41 test cases with priority semaphore
+++

threadqextractfifo.c:55
HARD
extract thread that isn't blocked on thread queue
+++

threadqextractpriority.c:64
HARD
extract thread that isn't blocked on thread queue
+++

heapresizeblock.c:158
Simple Test Case
looks like shrink block but so small the unused area gets freed
+++

killinfo.c:233
Simple Test Case
signals to blocked/ready tasks with particular settings
+++

killinfo.c:325
Simple Test Case
This is an error case where we can't allocate another signinfo structure.
+++

timerinserthelper.c:45
Interrupt Synchronization
We just removed the timer but the watchdog timer is being inserted by
a higher priority interrupt.  We may be able to get this to happen
with Classic API Timers.  But that is unclear.
+++

sigwait.c:43
Simple Test Case
This routine is implemented as a wrapper for sigtimedwait() and this is
the error path.  We just need a simple error test case.
+++

sigtimedwait.c:42
Simple Test Case
This is an error case where no POSIX real-time signals are set. (I think)
+++
