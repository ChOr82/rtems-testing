
cancelrun.c:44
Simple Test Case
This is simply an untested normal use of pthread cancellation handlers.
+++

setcancelstate.c:53
Simple Test Case
This is a missing error case.
+++

/opt/rtems-4.10/lib/gcc/sparc-rtems4.10/4.4.0/../../../../sparc-rtems4.10/include/pthread.h:280
Simple Test Case
Really setcancelstate.c:65 and setcanceltype.c:65. Apparently we don't
hit the end of this if which sets cancel = true.

Could possibly share cancellation evaluatation code with setcanceltype.c
and setcancelstate.c.
+++

/opt/rtems-4.10/lib/gcc/sparc-rtems4.10/4.4.0/../../../../sparc-rtems4.10/include/pthread.h:281
Simple Test Case
Really setcancelstate.c:65 and setcanceltype.c:65. Apparently we don't
hit the end of this if which sets cancel = true.

Could possibly share cancellation evaluatation code with setcanceltype.c
and setcancelstate.c.
+++

setcancelstate.c:69
Simple Test Case
This is actually two cases because of how the exit code it generated.

One is really line 69.  We do not hit the cancellation requested but
deferred case where we will need to run the handners.

The other is a branch from line 50 for !oldstate.

Could possibly share cancellation evaluatation code with setcanceltype.c.
+++

setcanceltype.c:53
Simple Test Case
This is a missing error case.
+++

setcanceltype.c:68
Simple Test Case
This is actually two cases because of how the exit code it generated.

One is really line 68.  We do not hit the cancellation requested but
deferred case where we will need to run the handners.

The other is a branch from line 50 for !oldtype.

Could possibly share cancellation evaluatation code with setcanceltype.c.
+++

condwaitsupp.c:59
Simple Test Case
This code is either easy or impossible to hit.  The condition variable is
associated with a mutex but it is not the one we are specifying.  Probably
will require having two threads wait on the same condition variable but
each uses a different mutex.
+++

condget.c:44
Simple Test Case
I think this is running out of condition variables while using automatic
allocation.
+++

keycreate.c:80
Simple Test Case
Run out of memory while allocating key memory.
+++

keycreate.c:82
Simple Test Case
Run out of memory while allocating key memory.
+++

keyrundestructors.c:62
Simple Test Case
Restructure the code into 3 separate tests with continues and see which
cases are really not hit. Then trigger the cases.
+++

keyrundestructors.c:64
Simple Test Case
Probably Iterating over a NULL value.
+++

mqueuecreatesupp.c:101
Simple Test Case
This is running out of message queues.
+++

mqueue.inl:60
Simple Test Case
Really two cases.

mqueuecreatesupp.c:119 is running out of memory allocating the name.

mqueuecreatesupp.c:142 is failing the core message queue initialize.
Probably running out of memory while allocating the buffer memory.
+++

mqueuedeletesupp.c:57
Simple Test Case
This is a case of deleting a named message queue.
+++

mqueuetimedreceive.c:71
Simple Test Case or Restructure switch to if
Given that this is 3 instructions, it is probably a missed test case.
+++

mqueuetimedsend.c:71
Simple Test Case or Restructure switch to if
Given that this is 3 instructions, it is probably a missed test case.
+++

psignal.c:148
?
This appears to be a case of not exercising the loop fully.
+++

mutexinit.c:165
Simple Test Case
This code is not initializing a specific type of mutex -- probably recursive.
+++

mutextimedlock.c:59
Simple Test Case (or Restructure)
Looks like another undertested timeout path.
+++

pthread.c:83
Simple Test Case
This is a case of the sporadic scheduling budget being less than one clock
tick in length.
+++

pthread.c:97
Simple Test Case
This is a case of the sporadic scheduling replinish period being less
than one clock tick in length.
+++

pthread.c:129
Simple Test Case
This is a case of attempting to change the priority of a thread
holding resources at the end of the sporadic server period.
+++

pthread.c:130
Simple Test Case
It looks like we don't have a good sporadic server test.  This is
the normal case of changin priority.
+++

eventsurrender.c:81
Interrupt Synchronization
This is executed when events are sent to the currently executing thread
while it is in the process of blocking.  I think sp39 or sp41 relates to
this but may not be hitting the correct combination of timed out or Any/All.

NOTE: This is hit sometimes so maybe the tests need tuning a bit.
+++

eventsurrender.c:82
Interrupt Synchronization
This is somehow related to eventsurrender.c:81 but the range is
disconnected and I do not see why with certainty.  This could be
when a timeout occurs while we are blocking on an event receive.
+++

eventtimeout.c:78
Interrupt Synchronization
This is a timeout while blocking waiting for an event receive with timeout.
+++

ratemontimeout.c:61
Simple Test Case
period times out but thread is blocked on another period?
+++

ratemonperiod.c:310
Interrupt Synchronization
period must expire while attempting to block
+++

watchdog.inl:129
Interrupt Synchronization

period expires while blocking (ratemontimeout.c:66)
+++

timerreset.c:60
Simple Test Case
new error case
+++

timerserverfireafter.c:80
Interrupt Synchronization
timer must be inserted by an ISR while we are inserting it
+++

semcreate.c:163
Simple Test Case
need to create a semaphore that is RTEMS_PRIORITY_CEILING
+++

coremutex.inl:171
Simple Test Case
pri ceiling, acquire when pri = ceiling
+++

coremutexsurrender.c:188
Simple Test Case
There must not be a test of a priority ceiling mutex getting released
which results in a thread being unblocked and the UNBLOCKED thread's
priority being elevated.
+++

corespinlockwait.c:69
Simple Test Case
The spinlock is not available and the caller is not willing to wait.
Requires a test of pthread_spin_trylock.
+++

corespinlockrelease.c:59
Simple Test Case
Attempt to release a locked spinlock from a thread that is not the one
which locked it.
+++

semflush.c:82
Simple Test Case
need to flush a NOT counting semaphore
+++

debug.c:63
Simple Test Case
need a test
+++

heapresizeblock.c:158
Simple Test Case
looks like shrink block but so small the unused area gets freed
+++

objectshrinkinformation.c:101
Talk To Chris
This code needs to be explained by Chris and possibly restructured.
I think this is possibly dead code where a branch case cannot actually
be taken because it is redundant.  But more than than that, I am not
100% sure the code is correct. I am unsure how the loop ensures that
all objects within an allocation block are verified as being free.
+++

objectidtoname.c:78
Simple Test Case
I find it hard to believe that this is not already covered but the code
appears to be the exit path for the successful lookup of an id to return
the object's name. Verify the lack of a test case and add one.  If there
is a test case that would appear to cover this, investigate.
+++

objectgetinfo.c:36
Dead Code?
This appears to be a case where a number which should be unsigned
(and maybe isn't) is being checked for being negative.  The method
being called probably should be changed to return an unsigned int
and the < 0 comparison removed.
+++

pheapgetinfo.c:40
Simple Test Case
This appears to be the exit path for all errors in this routine.  Obviously
there are no tests for errors.
+++

heapallocatealigned.c:223
Simple Test Case
This looks like a case where the allocate aligned simply fails to get any
memory.
+++

heapgetinfo.c:70
Simple Test Case
The heap is corrupted.  The block's size does not match the next block's
previous size backwards link.  This may make sense to add to the
Heap Walk test.
+++

heapresizeblock.c:144
Simple Test Case
Shrink a heap block with the resize.  The block after this one in memory
must be free so the memory free by the shrinking will be merged with that
already free block.
+++

heapwalk.c:144
Test Case
We are not hitting the case for having an error at this place.  I would have
thought that making do_dump 0 and running all the cases is enough.  Maybe the
test does not do what I think and this is why this case is missed.
+++

regionresizesegment.c:83
Simple Test Case
Apparently we do not have a test case where there is memory freed by the
resize effort is sufficient to result in needing to look to see if we
can unblock any tasks.
+++

ioregisterdriver.c:61
Simple Test Case
documented (not implemented) in sp40.  Fill up the driver table and
register another driver.
+++

ioregisterdriver.c:71
Simple Test Case
documented (not implemented) in sp40.  Fill up the driver table and
register another driver.  All of the cases in this file are probably
related and will take attention when working on them to be sure I
have explained them correctly.  The assembly is just hard to follow.
+++

ioregisterdriver.c:84
Simple Test Case
if reachable
+++

dpmemcreate.c:87
Simple Test Case
need invalid address of return id
+++

timerfireafter.c:76
Interrupt Synchronization
timer must be inserted or state altered by ISR
+++

thread.inl:230
SHOULD BE COVERED
sp39 should cover this .. timeout while blocking (eventtimeout.c:71)
+++

thread.inl:47
Simple Test Case
(sys state trickery) shutdown while in shutdown state
+++

threadget.c:88
Simple Test Case
This will require adding a POSIX test where only Classic API tasks are
configured and what should be the valid Id of a POSIX thread is passed
to any thread/task routine.
+++

threadinitialize.c:91
Simple Test Case
This is for the case where the application uses the POSIX 
thread stack address attribute.

NOTE: Code Should be Configured on POSIX
+++

threadinitialize.c:148
Medium Test Case
The allocation of the user extension data area must fail.  The failure should
occur during the create case of an Floating Point enabled task.

Since the stack is allocated first, it should be possible to have a test
with a fair (16-32?) number of user extensions configured and then
create a thread with increasingly larger stack until this case is hit.
+++

threadinitialize.c:188
Simple Test Case
There must not be a thread/task created
with THREAD_CPU_BUDGET_ALGORITHM_EXHAUST_TIMESLICE.
+++

threadinitialize.c:233
Simple Test Case
Add case with user extension which fails to allocate memory on create
+++

iterateoverthreads.c:42
Simple Test Case
Need to call iterate over threads in a test where there is an API configured
which does not have threads.  Should be easy to add to sp54.
+++

threadqenqueuepriority.c:92
Interrupt Synchronization
This case is where we are iterating to enqueue a thread into a priority
based thread queue but the thread we are looking at gets unblocked when
we flash interrupts. 
+++

threadqenqueuepriority.c:131
Simple Test Case
I think! this is a case where we enqueue by priority with a thread 
priority that requires searching from last to first.  But there is
already a thread priority on the chain.  This priority will go before
any in the set.  So we search backwards and insert at the head.
+++

threadreset.c:63
Simple Test Case
This is a case where a task is restarted with its per task watchdog
timer active. This probably can be hit by having a task do a long
wake after and another thread restart it.
+++

corebarrierwait.c:64
Simple Test Case
This looks like a simple test case of being a automatically released 
barrier and being the Nth task to block so tripping the automatic release.
+++

chain.inl:300
Simple Test Case or Minor Code Rework
This inlined case appears multiple times.

_POSIX_signals_Clear_signals:71 chain get when empty

This is actually part of _Watchdog_Adjust_to_chain and it appears to be
dead because there is an explicit check for the chain being empty on the
loop but the _Chain_Get_unprotected also checks for empty.  So we never
get a case there _Chain_Get_unprotected returns NULL.  May be able to
rework the loop to repeated call get until it gets a NULL.
+++

threadqenqueuepriority.c:139
Interrupt Synchronization
restart insertion search
+++

threadqenqueuepriority.c:189
Simple Test Case
need sp41 test cases with priority semaphore
+++

threadqextractfifo.c:55
Simple Test Case
extract thread that isn't blocked on thread queue.  Probably requires
bypassing APIs and going to SuperCode directly. Hard if API not bypassed.
+++

threadqextractpriority.c:64
Simple Test Case
extract thread that isn't blocked on thread queue.  Probably requires
bypassing APIs and going to SuperCode directly. Hard if API not bypassed.
+++

threadqfirstpriority.c:51
Simple Test Case
Ask for first priority on a thread queue with no tasks.  May require
bypassing APIs and going to SuperCode directly. Hard if API not bypassed.
+++

threadqprocesstimeout.c:46
Interrupt Synchronization
This is processing a timeout on a thread that times out while it is in the
process of blocking on a thread queue.
+++

threadqprocesstimeout.c:54
Interrupt Synchronization
This is the return code from threadqprocesstimeout.c:46.  Perhaps
restructuring this code will make it easier to combine these.  Hit the
normal path first and return.  Then fall into the unusual synchronization
path.
+++

timespecdivide.c:44
Simple Test Case
Will probably have to bypass the APIs but this is a divide by zero case.
+++

watchdogadjusttochain.c:42
Simple Test Case?
I think this is a case where there are multiple items on the chain which
are at the same time (0 delta).
+++

watchdoginsert.c:52
Interrupt Synchronization
This is when a higher priority interrupt inserts a timer while a lower
priority interrupt is inserting one.
+++

watchdogremove.c:41
Interrupt Synchronization
Remove a watchdog while it is being inserted.
+++

watchdogremove.c:64
Interrupt Synchronization
Remove a watchdog while it is being removed.
+++

userextremoveset.c:34
Simple Test Case
Remove a user extension set with a context switch extension.  Add to
existing extension test.
+++

userextthreadcreate.c:43
Simple Test Case
Task create user extension fails.
+++

killinfo.c:152
Simple Test Case
Yet another path through here.
+++

killinfo.c:212
Simple Test Case
Multiple threads interested but find high priority one first.
+++

killinfo.c:247
Simple Test Case
Yet another path through here.
+++

killinfo.c:339
Simple Test Case
This is an error case where we can't allocate another signinfo structure.
+++

timerinserthelper.c:45
Interrupt Synchronization
We just removed the timer but the watchdog timer is being inserted by
a higher priority interrupt.  We may be able to get this to happen
with Classic API Timers.  But that is unclear.
+++
