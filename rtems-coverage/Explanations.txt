
cancelrun.c:44
Simple Test Case
This is simply an untested normal use of pthread cancellation handlers.
+++

setcancelstate.c:50
Simple Test Case
A very simple test case where a NULL pointer to the oldstate is passed in.
+++

setcancelstate.c:65
Simple Test Case
The other is a branch from line 50 for !oldstate.
+++

setcanceltype.c:50
Simple Test Case
This is a case of passing in a bad cancelation type.
+++

setcanceltype.c:64
Simple Test Case
The other is a branch from line 50 for bad type.
+++

keycreate.c:80
Simple Test Case
Run out of memory while allocating key memory.
+++

keycreate.c:82
Simple Test Case
Run out of memory while allocating key memory.
+++

keyrundestructors.c:62
Simple Test Case
Restructure the code into 3 separate tests with continues and see which
cases are really not hit. Then trigger the cases.
+++

keyrundestructors.c:64
Simple Test Case
Probably Iterating over a NULL value.
+++

mqueuecreatesupp.c:101
Simple Test Case
This is running out of message queues.
+++

mqueue.inl:60
Simple Test Case
Really two cases.

mqueuecreatesupp.c:119 is running out of memory allocating the name.

mqueuecreatesupp.c:142 is failing the core message queue initialize.
Probably running out of memory while allocating the buffer memory.
+++

mqueuedeletesupp.c:57
Simple Test Case
This is a case of deleting a named message queue.
+++

mqueuetimedreceive.c:71
Simple Test Case or Restructure switch to if
Given that this is 3 instructions, it is probably a missed test case.
+++

mqueuetimedsend.c:71
Simple Test Case or Restructure switch to if
Given that this is 3 instructions, it is probably a missed test case.
+++

psignal.c:148
?
This appears to be a case of not exercising the loop fully.
+++

mutexinit.c:165
Simple Test Case
This code is not initializing a specific type of mutex -- probably recursive.
+++

mutextimedlock.c:59
Simple Test Case (or Restructure)
Looks like another undertested timeout path.
+++

pthread.c:83
Simple Test Case
This is a case of the sporadic scheduling budget being less than one clock
tick in length.
+++

pthread.c:97
Simple Test Case
This is a case of the sporadic scheduling replinish period being less
than one clock tick in length.
+++

pthread.c:129
Simple Test Case
This is a case of attempting to change the priority of a thread
holding resources at the end of the sporadic server period.
+++

pthread.c:130
Simple Test Case
It looks like we don't have a good sporadic server test.  This is
the normal case of changin priority.
+++

timerreset.c:60
Simple Test Case
new error case
+++

timerserverfireafter.c:80
Interrupt Synchronization
timer must be inserted by an ISR while we are inserting it
+++

coremutex.inl:171
Simple Test Case
pri ceiling, acquire when pri = ceiling
+++

coremutexsurrender.c:188
Simple Test Case
There must not be a test of a priority ceiling mutex getting released
which results in a thread being unblocked and the UNBLOCKED thread's
priority being elevated.
+++

heapresizeblock.c:158
Simple Test Case
looks like shrink block but so small the unused area gets freed
+++

heapallocatealigned.c:223
Simple Test Case
This looks like a case where the allocate aligned simply fails to get any
memory.
+++

heapgetinfo.c:70
Simple Test Case
The heap is corrupted.  The block's size does not match the next block's
previous size backwards link.  This may make sense to add to the
Heap Walk test.
+++

heapresizeblock.c:144
Simple Test Case
Shrink a heap block with the resize.  The block after this one in memory
must be free so the memory free by the shrinking will be merged with that
already free block.
+++

heapwalk.c:144
Test Case
We are not hitting the case for having an error at this place.  I would have
thought that making do_dump 0 and running all the cases is enough.  Maybe the
test does not do what I think and this is why this case is missed.
+++

regionresizesegment.c:83
Simple Test Case
Apparently we do not have a test case where there is memory freed by the
resize effort is sufficient to result in needing to look to see if we
can unblock any tasks.
+++

ioregisterdriver.c:61
Simple Test Case
documented (not implemented) in sp40.  Fill up the driver table and
register another driver.
+++

ioregisterdriver.c:71
Simple Test Case
documented (not implemented) in sp40.  Fill up the driver table and
register another driver.  All of the cases in this file are probably
related and will take attention when working on them to be sure I
have explained them correctly.  The assembly is just hard to follow.
+++

ioregisterdriver.c:84
Simple Test Case
if reachable
+++

timerfireafter.c:76
Interrupt Synchronization
timer must be inserted or state altered by ISR
+++

threadinitialize.c:91
Simple Test Case
This is for the case where the application uses the POSIX
thread stack address attribute.

NOTE: Code Should be Configured on POSIX
+++

threadinitialize.c:148
Medium Test Case
The allocation of the user extension data area must fail.  The failure should
occur during the create case of an Floating Point enabled task.

Since the stack is allocated first, it should be possible to have a test
with a fair (16-32?) number of user extensions configured and then
create a thread with increasingly larger stack until this case is hit.
+++

iterateoverthreads.c:42
Simple Test Case
Need to call iterate over threads in a test where there is an API configured
which does not have threads.  Should be easy to add to sp54.
+++

threadqenqueuepriority.c:99
Interrupt Synchronization
This case is where we are iterating to enqueue a thread into a priority
based thread queue but the thread we are looking at gets unblocked when
we flash interrupts.  It is NOT the thread we are unblocking.
Forward Search case.

NOTE: Do not remove this from the explanations since the test can vary.
+++

threadqenqueuepriority.c:146
Interrupt Synchronization
This case is where we are iterating to enqueue a thread into a priority
based thread queue but the thread we are looking at gets unblocked when
we flash interrupts.  It is NOT the thread we are unblocking.
Reverse Search case.

NOTE: Do not remove this from explanations.
+++

chain.inl:300
Simple Test Case or Minor Code Rework
This inlined case appears multiple times.

_POSIX_signals_Clear_signals:71 chain get when empty
_Watchdog_Adjust_to_chain may also have one.

This is actually part of multiple paths and it appears to be
dead because there is an explicit check for the chain being empty on the
loop but a call to _Chain_Get_unprotected also checks for empty.  So we never
get a case there _Chain_Get_unprotected returns NULL.  Can usually be
addressed by reworking the loop in some way.
+++

threadqprocesstimeout.c:46
Interrupt Synchronization
This is processing a timeout on a thread (that is NOT the thread executing)
that times out while another thread is in the process of blocking on
a thread queue.
+++

threadqprocesstimeout.c:54
Interrupt Synchronization
This is processing a timeout on a thread (that is the thread executing)
that has also had its request satisfied while it is being enqueued.
+++

watchdoginsert.c:52
Interrupt Synchronization
This is when a higher priority interrupt inserts a timer while a lower
priority interrupt is inserting one.
+++

watchdogremove.c:41
Interrupt Synchronization
Remove a watchdog while it is being inserted.
+++

watchdogremove.c:64
Interrupt Synchronization
Remove a watchdog while it is being removed.
+++

killinfo.c:152
Simple Test Case
Yet another path through here.
+++

killinfo.c:212
Simple Test Case
Multiple threads interested but find high priority one first.
+++

killinfo.c:247
Simple Test Case
Yet another path through here.
+++

killinfo.c:339
Simple Test Case
This is an error case where we can't allocate another signinfo structure.
+++

timerinserthelper.c:45
Interrupt Synchronization
We just removed the timer but the watchdog timer is being inserted by
a higher priority interrupt.  We may be able to get this to happen
with Classic API Timers.  But that is unclear.
+++
