
keycreate.c:80
Simple Test Case
Run out of memory while allocating key memory.
+++

keycreate.c:82
Simple Test Case
Run out of memory while allocating key memory.
+++

keyrundestructors.c:64
Simple Test Case
This is where a key is configured without a destructor.
+++

keyrundestructors.c:68
Simple Test Case
This is where a key is configured and created that this thread is not using.
+++

mqueuecreatesupp.c:101
Simple Test Case
This is running out of message queues.
+++

mqueue.inl:60
Simple Test Case
Really two cases.

mqueuecreatesupp.c:119 is running out of memory allocating the name.

mqueuecreatesupp.c:142 is failing the core message queue initialize.
Probably running out of memory while allocating the buffer memory.
+++

mqueuedeletesupp.c:57
Simple Test Case
This is a case of deleting a named message queue.
+++

psignal.c:148
?
This appears to be a case of not exercising the loop fully.
+++

mutexinit.c:165
Simple Test Case
This code is not initializing a specific type of mutex -- probably recursive.
+++

pthread.c:83
Simple Test Case
This is a case of the sporadic scheduling budget being less than one clock
tick in length.
+++

pthread.c:97
Simple Test Case
This is a case of the sporadic scheduling replenish period being less
than one clock tick in length.
+++

pthread.c:129
Simple Test Case
This is a case of attempting to change the priority of a thread
holding resources at the end of the sporadic server period.
+++

pthread.c:130
Simple Test Case
It looks like we don't have a good sporadic server test.  This is
the normal case of changing priority.
+++

coremutex.inl:171
Simple Test Case
pri ceiling, acquire when pri = ceiling
+++

coremutexsurrender.c:188
Simple Test Case
There must not be a test of a priority ceiling mutex getting released
which results in a thread being unblocked and the UNBLOCKED thread's
priority being elevated.
+++

heapresizeblock.c:158
Simple Test Case
looks like shrink block but so small the unused area gets freed
+++

heapallocatealigned.c:223
Simple Test Case
This looks like a case where the allocate aligned simply fails to get any
memory.
+++

heapgetinfo.c:70
Simple Test Case
The heap is corrupted.  The block's size does not match the next block's
previous size backwards link.  This may make sense to add to the
Heap Walk test.
+++

heapresizeblock.c:144
Simple Test Case
Shrink a heap block with the resize.  The block after this one in memory
must be free so the memory free by the shrinking will be merged with that
already free block.
+++

heapwalk.c:144
Test Case
We are not hitting the case for having an error at this place.  I would have
thought that making do_dump 0 and running all the cases is enough.  Maybe the
test does not do what I think and this is why this case is missed.
+++

regionresizesegment.c:83
Simple Test Case
Apparently we do not have a test case where there is memory freed by the
resize effort is sufficient to result in needing to look to see if we
can unblock any tasks.
+++

threadinitialize.c:91
Simple Test Case
This is for the case where the application uses the POSIX
thread stack address attribute.

NOTE: Code Should be Configured on POSIX
+++

threadinitialize.c:148
Medium Test Case
The allocation of the user extension data area must fail.  The failure should
occur during the create case of an Floating Point enabled task.

Since the stack is allocated first, it should be possible to have a test
with a fair (16-32?) number of user extensions configured and then
create a thread with increasingly larger stack until this case is hit.
+++

chain.inl:300
Simple Test Case or Minor Code Rework
This inlined case has appeared multiple times but this last one appears 
to be code in the following which probably needs rework.

_POSIX_signals_Clear_signals:71 chain get when empty

This is actually part of multiple paths and it appears to be
dead because there is an explicit check for the chain being empty on the
loop but a call to _Chain_Get_unprotected also checks for empty.  So we never
get a case there _Chain_Get_unprotected returns NULL.  Can usually be
addressed by reworking the loop in some way.
+++

threadqprocesstimeout.c:46
Interrupt Synchronization
This is a case there we are timing out a thread on the same thread
queue that the currently executing thread is in the process of blocking on.
+++

threadqprocesstimeout.c:54
Interrupt Synchronization
This is processing a timeout on a thread (that is the thread executing)
that has also had its request satisfied while it is being enqueued.
+++

killinfo.c:145
Simple Test Case
This is a weird case where a thread is on the sigwait list waiting
for one signal.  We send another that it hasn't blocked.  This will
be easy with a dedicated test.

Line number has moved.  Hopefully this is the case.  Analyze before
writing code.
+++

chain.inl:111
Simple Test Case
See killinfo.c case above.
+++

killinfo.c:336
Simple Test Case
This is an error case where we can't allocate another siginfo structure.
I suspect this will be easier with a dedicated test.
+++
