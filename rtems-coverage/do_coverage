#! /bin/sh
#
#  Script to perform a single coverage test run on a single BSP
#  in a specific configuration.  This script automates all steps
#  of building RTEMS, running the tests, and generating the reports.
#
#  $Id$
#

vfile=`dirname $0`/VERSIONS-COVERAGE
if [ ! -r ${vfile} ] ; then
  echo VERSIONS-COVERAGE file not found
  exit 1
fi

source ${vfile}

if [ ! -d ${BASEDIR} ] ; then
  echo Have you set the BASEDIR in VERSIONS correctly?
  exit 1
fi

progname=${0##*/}        # fast basename hack for ksh, bash

USAGE=\
"usage: $progname [ -opts ]
        -v        -- verbose (default=no)
        -A        -- Execute all steps (default=no)
        -B BSP    -- Specify BSP to test
        -P        -- Enable POSIX API (default=yes)
        -S        -- Optimize for size (default=no)
        -m        -- Update and build covMerge (default=no)
        -u        -- Do CVS update on RTEMS (default=no)
        -c        -- Configure RTEMS (default=no)
        -b        -- Build RTEMS (default=no)
        -C        -- copy tests from build to test execution point (default=no)
        -r        -- run the tests (default=no)
        -R        -- generate reports (default=no)
        -f        -- publish the results to ftp site (default=no)

Notes:  + There are currently NO checks at each step to determine if
          the previous steps were performed!!!
        + Use of each option toggles the setting.  For example, \"-v -v -A -u\"
          results in verbose=no and all steps done except CVS update on RTEMS.

"

#   log an error to stderr
prerr()
{
    echo "$*" >&2
}

fatal() {
    prerr "$USAGE"
    [ "$1" ] && (prerr ; prerr $*);
    exit 1
}

warn() {
    [ "$1" ] && prerr $*
}

check_status()
{
  if [ $1 -ne 0 ] ; then
    shift
    echo "FAILED: " "$*" >&2
    exit 1
  fi
}

toggle()
{
  case $1 in
    no)  echo "yes" ;;
    yes) echo "no" ;;
    *)   fatal "Unknown value to toggle ($1)" ;;
  esac
}

# parse arguments for these
verbose="no"
do_all="no"
do_posix="yes"
do_optimize_size="no"
do_covmerge="no"
do_rtems_update="no"
do_rtems_configure="no"
do_rtems_build="no"
do_copy_tests="no"
do_run_tests="no"
do_reports="no"
do_publish="no"
BSP="not_set"

while getopts vB:PSmAucbCrRf OPT
do
    case "$OPT" in
        A)
          do_all="yes"
          do_covmerge="yes"
          do_posix="yes"
          do_rtems_update="yes"
          do_rtems_configure="yes"
          do_rtems_build="yes"
          do_copy_tests="yes"
          do_run_tests="yes"
          do_reports="yes"
          ;;
        B) BSP="${OPTARG}";;
        v) verbose=`toggle ${verbose}` ;;
        m) do_covmerge=`toggle ${do_covmerge}` ;;
        P) do_posix=`toggle ${do_posix}` ;;
        S) do_optimize_size=`toggle ${do_optimize_size}` ;;
        u) do_rtems_update=`toggle ${do_rtems_update}` ;;
        c) do_rtems_configure=`toggle ${do_rtems_configure}` ;;
        b) do_rtems_build=`toggle ${do_rtems_build}` ;;
        C) do_copy_tests=`toggle ${do_copy_tests}` ;;
        r) do_run_tests=`toggle ${do_run_tests}` ;;
        R) do_reports=`toggle ${do_reports}` ;;
        f) do_publish=`toggle ${do_publish}` ;;
        *) fatal;;
    esac
done

#  If we are to update or configure RTEMS, then we need to clean the
#  RTEMS build tree up.
do_clean="no"
if [ ${do_rtems_update} = "yes" -o \
     ${do_rtems_configure} = "yes" ] ; then
  do_clean="yes"
fi

# allow bsp override
if [ ${BSP} == "not_set" ] ; then
  fatal "No BSP selected"
fi

# you can't publish unless ftp directory is accessible
if [ ${do_publish} = "yes" ] ; then
  if [ ! -d ${FTPDIR} ] ; then
    fatal "Publishing results requested and ${FTPDIR} does not exist"
  fi
fi

# For most BSPs, there is a script with the same name as the BSP.
RUNNER=${BSP}

RTEMSEXT=ralf
case ${BSP} in
  pc386)
    CPU=i386
    COVERAGE_FORMAT=QEMU
    RTEMS_EXTRA_ARGS="USE_COM1_AS_CONSOLE=1"
    RTEMS_EXTRA_ARGS="${RTEMS_EXTRA_ARGS} BSP_PRESS_KEY_FOR_RESET=0"
    ;; 
  uC5282)
    CPU=m68k
    COVERAGE_FORMAT=QEMU
    ;;
  qemuppc)
    CPU=powerpc
    COVERAGE_FORMAT=QEMU
    ;;
  erc32|leon2|leon3)
    CPU=sparc
    COVERAGE_FORMAT=TSIM
    ;;
  edb7312|rtl22xx|gumstix|smdk2410)
    CPU=arm
    COVERAGE_FORMAT=Skyeye
    RTEMS_EXTRA_ARGS="ON_SKYEYE=1"
    ;;
  *)
    fatal "Unsupported BSP (${BSP}) for coverage analysis."
    ;;
esac

if [ ${RTEMS_VERSION} = 4.6 ] ; then
  TARGET=${CPU}-rtems
else
  TARGET=${CPU}-rtems${RTEMS_VERSION}
fi

##### VERBOSE
print_verbose()
{
  echo "BSP:                " ${BSP}
  echo "Target:             " ${TARGET}
  echo "do_all:             " ${do_all}
  echo "do_covmerge         " ${do_covmerge}
  echo "do_posix:           " ${do_posix}
  echo "do_optimize_size:   " ${do_optimize_size}
  echo "do_rtems_update:    " ${do_rtems_update}
  echo "do_rtems_configure: " ${do_rtems_configure}
  echo "do_rtems_build:     " ${do_rtems_build}
  echo "do_copy_tests:      " ${do_copy_tests}
  echo "do_run_tests:       " ${do_run_tests}
  echo "do_reports:         " ${do_reports}
  echo "do_publish:         " ${do_publish}
  echo "Clean Before:       " ${do_clean}
}

if [ ${verbose} = "yes" ] ; then
  print_verbose
fi

# Basic error checking and sanity checking on the directory structure
# and PATH
if [ ! -d ${COVBASE} ] ; then
  echo "The directory you specified for the base of the coverage run is "
  echo "not present. (${COVBASE})"
  exit 1
fi

if [ ! -d ${RTEMSDIR} ] ; then
  echo "Check out RTEMS!!!"
  exit 1
fi

type ${TARGET}-gcc
check_status $? "Path appears to be broken"

# Start real action
NM=${TARGET}-nm
type ${NM}
check_status $? "Cannot find ${NM} on PATH"

# Locate the custom file
custom=${RTEMSDIR}/make/custom/${BSP}.cfg
if [ ! -r ${custom} ] ; then
  custom=`ls -1 \
     ${RTEMSDIR}/c/src/lib/libbsp/${CPU}/*/make/custom/${BSP}.cfg 2>/dev/null`
  if [ x${custom} = x -o ! -r ${custom} ] ; then
    echo "Unable to read ${custom}"
    exit 1
  fi
fi

grep "^CFLAGS_OPTIMIZE_V.*=.*-O[2s]" ${custom} >/dev/null
if [ $? -ne 0 ] ; then
  echo "Unable to file CFLAGS_OPTIMIZE_V in ${custom}"
  exit 1
fi

if [ ${do_optimize_size} = yes ] ; then
 c_opt=-Os
else
 c_opt=-O2
fi

EXTENSION=${c_opt}
if [ ${do_posix} = yes ] ; then
  EXTENSION=${EXTENSION}P
else
  EXTENSION=${EXTENSION}p
fi

day=`date +%Y%m%d`
hour=`date +%H`
minute=`date +%M`

echo "Testing ${TARGET}/${BSP} at optimization (${c_opt})"

# print a data element in table
print_element()
{
  echo "  <TD>"${*}"</TD>"
}

# generate table row of results in html
generate_html()
{
  echo "<TR>"
    print_element ${day}
    print_element ${hour}:${minute}
    print_element ${c_opt}
    print_element ${do_posix}
    print_element ${do_developmental}
    print_element `grep "Uncovered range" summary.txt | cut -d ':' -f2`
    print_element `grep "age Not Exec" summary.txt | cut -d ':' -f2`
    print_element `grep "age Exec" summary.txt | cut -d ':' -f2`
    print_element `grep "Bytes Not Exec" summary.txt | cut -d ':' -f2`
    print_element `grep "Bytes Analyzed" summary.txt | cut -d ':' -f2`
    print_element "<A HREF=\"${results_dir}\">untarred</A> " \
                  "<A HREF=\"${results_dir}.tar.bz2\">tarball</A> "
  echo "</TR>"
}

# generate the coverage report set
generate_reports()
{
  if [ $# -ne 3 ] ; then
    echo Usage: ${0} TARGET BSP COVERAGE_FORMAT
    exit 1
  fi

  TARGET=${1}
  BSP=${2}
  COVERAGE_FORMAT=${3}

  cd ${BASEDIR}/${BSP}-tests/
  check_status $? "cd ${BSP}-tests"

  rm -f summary.txt annotated.txt uncovered.txt branch.txt sizes.txt

  ( check_endof ; \
    echo "Optimization Level : " ${c_opt} ; \
    echo "POSIX Enabled      : " ${do_posix} ; \
    echo "Developmental Code : " ${do_developmental} ; \
  ) >summary.txt
  ${COVBASE}/covoar \
    -T ${TARGET} \
    -f ${COVERAGE_FORMAT} \
    -E ${COVBASE}/Explanations.txt \
    -e ralf -c ralf.cov \
    *.ralf >> summary.txt
  check_status $? "covoar failed"

  (echo "====== Largest Range Sizes (Size and Count)======" ; \
    grep ^Size uncovered.txt | cut -d':' -f2 | sort -n | uniq -c | \
       tail -15 | sed -e 's/ *\([0-9]*\) *\([0-9]*\)/\2 \1/' | sort -n -r | \
       while read l; do printf "%6d %6d\n" $l; done ; \
    echo "=====================================" ) >>summary.txt

  generate_html >row.html

  cat summary.txt

  # Now create the archive of information
  rm -rf ${results_dir}
  mkdir ${results_dir}
  cp annotated.txt branch.txt configuration.txt sizes.txt summary.txt \
     uncovered.txt row.html ${results_dir}
  cp ${COVBASE}/Explanations.txt.NotFound ${results_dir}
  echo "Results saved in ${results_dir}.tar.bz2"
  tar cjf ${results_dir}.tar.bz2 ${results_dir}
  rm -rf ${results_dir}
}

# This grabs the list of methods from a library or object file
filter_nm()
{
  for l in $*
  do
    test ${verbose} = "yes" && echo Generating symbols from ${l} >&2
    # echo "========= START $l"
    ${TARGET}-nm --format=sysv $l | grep "FUNC|" | \
      cut -d'|' -f1 | sed -e 's/ *$//'
    # echo "========= END $l"
  done
}

# generate the list of symbols to analyze
generate_symbols()
{
  cd ${BASEDIR}/b-${BSP}/${TARGET}/c/${BSP}/cpukit
  check_status $? "could not cd to object directory"

  # Base set of libraries to analyse.  Do NOT include libscorecpu.a!!!
  filter_nm score/libscore.a sapi/libsapi.a rtems/librtems.a

  # Now add the POSIX API onto that
  if [ ${do_posix} = "yes" ] ; then
    filter_nm posix/libposix.a
  fi

  # Now add developmental libraries
  # NOTE: all non-network libraries are listed here.  --joel 5 March 2010
  if [ ${do_developmental} = "yes" ] ; then
    # filter_nm libfs/librfs.a
    # filter_nm libfs/libdosfs.a
    filter_nm libfs/libimfs.a
    filter_nm libcsupport/libcsupport.a
    # filter_nm libi2c/libi2c.a
    # filter_nm zlib/libz.a
    # filter_nm libmd/libmd.a
    # filter_nm libmisc/libshell.a
    filter_nm libmisc/libbspcmdline.a
    filter_nm libmisc/libcpuuse.a
    # filter_nm libmisc/libuuid.a
    filter_nm libmisc/libstackchk.a
    # filter_nm libmisc/libmw-fb.a
    # NEVER INCLUDE libdummy.a!!!
    # filter_nm libmisc/libdummy.a
    # filter_nm libmisc/libfsmount.a
    filter_nm libmisc/libstringto.a
    filter_nm libmisc/libdevnull.a
    # filter_nm libmisc/libcapture.a
    filter_nm libmisc/libdumpbuf.a
    # filter_nm libmisc/libmonitor.a
    # filter_nm libmisc/libserdbg.a
    # filter_nm libmisc/libuntar.a
    # filter_nm libblock/libblock.a
  fi
}

# Now we are ready to start doing real work
start=`date`

# If necessary, clean up the RTEMS build and test run directories
if [ ${do_clean} = "yes" ] ; then
  echo "Cleaning before building"
  rm -rf ${BASEDIR}/b-${BSP}
  rm -rf ${BASEDIR}/${BSP}-tests
else
  echo "Skipping clean before building"
fi

# If they don't exist, create the RTEMS build and test run directories
test -d ${BASEDIR}/b-${BSP}     || mkdir ${BASEDIR}/b-${BSP}
test -d ${BASEDIR}/${BSP}-tests || mkdir ${BASEDIR}/${BSP}-tests

# If requested, update and build the coverage support tools
if [ ${do_covmerge} = "yes" ] ; then
  echo "Updating and building covmerge..."

  cd ${COVBASE}
  check_status $? "cd covmerge"

  cvs up -Pd 2>&1 | grep -v ^cvs
  make clean all
  check_status $? "build covmerge"

  make
  check_status $? "make covmerge"
else
  echo "Skipping Updating and building covmerge..."
fi

# If requested, update the RTEMS tree
if [ ${do_rtems_update} = "yes" ] ; then
  echo "Updating RTEMS ..."
  cd ${RTEMSDIR}
  check_status $? "cd rtems"

  cvs up -Pd 2>&1 | grep -v ^cvs
  ./bootstrap -c
  ./bootstrap
else
  echo "Skipping Updating RTEMS ..."
fi

# If requested, configure RTEMS
if [ ${do_rtems_configure} = "yes" ] ; then
  # Now let's patch the make/custom file
  sed -e "s/-O[2s]/${c_opt}/" <${custom} >/tmp/XXX
  mv /tmp/XXX ${custom}

  echo "Configuring RTEMS..."
  rm -rf ${BASEDIR}/b-${BSP}/
  mkdir ${BASEDIR}/b-${BSP}/
  cd ${BASEDIR}/b-${BSP}/
  check_status $? "cd b-${BSP}"

  ##################
  ################## WARNING!!!!!!
  ##################
  ################## BE CAREFUL ABOUT THIS CONFIGURE COMMAND.  IT IS
  ################## VERY SPECIFIC TO COVERAGE TESTING
  ##################
  if [ ${do_posix} = "yes" ] ; then
    posix_en=en
  else
    posix_en=dis
  fi

  if [ ${do_developmental} = "yes" ] ; then
    EXPERIMENTAL_ARG="experimental"
  else
    EXPERIMENTAL_ARG="yes"
  fi

  ${RTEMSDIR}/configure NDEBUG=1 \
    RTEMS_DO_NOT_INLINE_THREAD_ENABLE_DISPATCH=1 \
    RTEMS_DO_NOT_INLINE_CORE_MUTEX_SEIZE=1 \
    RTEMS_DO_NOT_UNROLL_THREADQ_ENQUEUE_PRIORITY=1 \
    ${RTEMS_EXTRA_ARGS} \
    --target=${TARGET} --enable-rtemsbsp=${BSP} \
    --enable-maintainer-mode \
    --enable-coverage=${EXPERIMENTAL_ARG} \
    --disable-itron --${posix_en}able-posix --enable-tests \
    --disable-tcpip --disable-ada --disable-cxx \
    --prefix=${BASEDIR}/coverage/install >c.log 2>&1
  check_status $? "configuring RTEMS for ${BSP}"
else
  echo "Skipping Configuring RTEMS ..."
fi

# If requested, build RTEMS
if [ ${do_rtems_build} = "yes" ] ; then
  echo "Building RTEMS..."

  cd ${BASEDIR}/b-${BSP}/
  check_status $? "cd b-${BSP}"

  make -j4 >b.log 2>&1
  check_status $? "Building RTEMS for ${BSP}"
else
  echo "Skipping Building RTEMS ..."
fi

# If requested, copy the tests from the build tree to the run tree
if [ ${do_copy_tests} = "yes" ] ; then
  echo "Copying tests..."

  # clean destination
  rm -rf ${BASEDIR}/${BSP}-tests/*
  check_status $? "clean test directory"

  cd ${BASEDIR}/b-${BSP}/
  check_status $? "cd b-${BSP}"

  find `pwd` -name "*.ralf" -o -name "*.exe" | while read f
  do
    rm -f ../${BSP}-tests/`basename ${f}`
    ln -s ${f} ../${BSP}-tests
  done
  
else
  echo "Skipping copying tests..."
fi

# If requested, run the tests with coverage reporting enabled
if [ ${do_run_tests} = "yes" ] ; then
  echo "Running tests..."
  cd ${BASEDIR}/${BSP}-tests/
  check_status $? "cd ${BSP}-tests"

  time ${RUNNER} -c *.${RTEMSEXT}
else
  echo "Skipping Running tests..."
fi

# If requested, generate the coverage reports
if [ ${do_reports} = "yes" ] ; then
  echo "Generating reports..."

  # Generate the configuration settings file
  ( \
    echo "#"
    echo "#  Settings for this coverage test run"
    echo "#"
    echo
    echo "Compiler version:   " `${TARGET}-gcc --version  | grep gcc`
    echo "Optimization flag   " ${c_opt}
    print_verbose
  ) > ${BASEDIR}/${BSP}-tests/configuration.txt

  cd ${BASEDIR}/${BSP}-tests/
  check_status $? "cd ${BSP}-tests"

  for do_developmental in no yes
  do
    if [ ${do_developmental} = yes ] ; then
      echo "Processing coverage for developmental configuration ..."
      EXT=${EXTENSION}D
    else
      echo "Processing coverage for core source configuration ..."
      EXT=${EXTENSION}d
    fi
    results_dir=${BSP}${EXT}-${day}-${hour}${minute}

    generate_symbols >${BASEDIR}/${BSP}-tests/rtems.syms

    generate_reports ${TARGET} ${BSP} ${COVERAGE_FORMAT}
  done
else
  echo "Skipping Generating reports..."
fi

# If requested, publish the coverage reports
if [ ${do_publish} = "yes" ] ; then
  if [ -d ${BASEDIR}/${BSP}-tests ] ; then
    cd ${BASEDIR}/${BSP}-tests/
    cp ${BSP}${EXTENSION}[dD]-${day}-${hour}${minute}.tar.bz2 ${FTPDIR}
    check_status $? "cp ${BSP} results to ftp site failed"
    ${COVBASE}/generate_coverage_html ${FTPDIR}
  else
    echo "No results to publish"
  fi
else
  echo "Skipping Publishing reports..."
fi
stop=`date`

echo "Started: " ${start}
echo "Stopped: " ${stop}

exit 0

