#! /bin/sh
#
#  Test Driver
#
#  $Id$
#

vfile=`dirname $0`/../VERSIONS
if [ ! -r ${vfile} ] ; then
  echo VERSIONS file not found
  exit 1
fi

source ${vfile}

if [ ! -d ${BASEDIR} ] ; then
  echo Have you set the BASEDIR in VERSIONS correctly?
  exit 1
fi

BASEDIR=`pwd`

for d in ${AUTOCONF} ${AUTOMAKE} ${BINUTILSDIR} \
    ${GDBDIR} ${NEWLIBDIR} ${GCCDIR}
do
  if [ ! -d ${d} ] ; then
    echo "Cannot locate ${d} -- aborting"
    exit 1
  fi
done

toggle()
{
  case $1 in
    no)  echo "yes" ;;
    yes) echo "no" ;;
    *)   fatal "Unknown value to toggle ($1)" ;;
  esac
}

usage()
{
cat <<EOF
do_one [options] CPU ..  CPU
  -A - enable clean, native, and update
  -a - build Ada (default=yes)
  -c - clean install point (also installs auto tools)
  -m - mail results to lists (default=yes)
  -n - build native
  -T - run tests (default=yes)
  -u - update GNU source if version from CVS/SVN
  -U - update RTEMS source if version from CVS/SVN (will bootstrap)
  -v - verbose
EOF
}

doCleanInstallPoint="no"
doUpdateTools="no"
doUpdateRTEMS="no"
doNative="no"
verbose="no"
doAda="yes"
doMail="yes"
doTests="yes"

while getopts AacmnuTUv OPT
do
  case "$OPT" in
    A) doCleanInstallPoint=`toggle ${doCleanInstallPoint}`
       doNative=`toggle ${doNative}`
       doUpdateTools=`toggle ${doUpdateTools}`
       doUpdateRTEMS=`toggle ${doUpdateRTEMS}`
       ;;
    a) doAda=`toggle ${doAda}` ;;
    c) doCleanInstallPoint=`toggle ${doCleanInstallPoint}` ;;
    m) doMail=`toggle ${doMail}` ;;
    n) doNative=`toggle ${doNative}` ;;
    T) doTests=`toggle ${doTests}` ;;
    u) doUpdateTools=`toggle ${doUpdateTools}` ;;
    U) doUpdateRTEMS=`toggle ${doUpdateRTEMS}` ;;
    v) verbose=`toggle ${verbose}` ;;
    *) usage; exit 1;
  esac
done

shiftcount=`expr $OPTIND - 1`
shift $shiftcount

args=$*

CPUs=""
for cpu in ${args}
do
  if [ ${cpu} = "native" ] ; then
    doNative="yes"
  else
    CPUs="${CPUs} ${cpu}"
  fi
done


if [ ${verbose} = "yes" ] ; then
  echo "Clean Install Point: " ${doCleanInstallPoint}
  echo "Install Autotools:   " ${doCleanInstallPoint}
  echo "Install Native:      " ${doNative}
  echo "Update Tool Source:  " ${doUpdateTools}
  echo "Update RTEMS:        " ${doUpdateRTEMS}
  echo "Build Ada            " ${doAda}
  echo "Email Results:       " ${doMail}
  echo "Run Tests:           " ${doTests}
  if [ "X${CPUs}" = "X" ] ; then
    echo "CPUs to Build:       " ALL
  else
    echo "CPUs to Build:       " ${CPUs}
  fi
fi

test ${doMail}  = "no"   && mailArg="-M"
test ${doTests} = "yes" && testArg="-T"
test ${doAda}   = "yes" && adaArg="-a"

start=`date`
echo Started at: ${start}

# HELPER - Update RTEMS
update_rtems()
{
  cd ${RTEMSDIR}
  if [ -d CVS ] ; then
    cvs up -Pd 2>&1 | grep -v ^cvs
    ./bootstrap -c
    ./bootstrap
  fi
}

# HELPER - Update GCC
update_gcc()
{
  cd ${GCCDIR}
  if [ -d .svn ] ; then
    grep "svn+ssh" .svn/entries >/dev/null
    if [ $? -eq 0 ] ; then
      echo "Skipping gcc update -- ssh keyed check out"
    else
      echo "Updating gcc -- anonymous check out"
      ./contrib/gcc_update
      if [ $? -ne 0 ] ; then
        echo "Update of GCC Failed."
        exit 1 
      fi
   fi
  fi
  return 0 
}

# HELPER - Remove all the installed previous builds
clean_up()
{
  rm -rf ${INSTALL}/* ${BSP_INSTALL}/*
}

install_auto()
{
  for auto in ${AUTOCONF} ${AUTOMAKE}
  do
    cd ${auto}
    make distclean
    ./configure --prefix=${INSTALL}
    make all install
  done
}

# This handles GNU tools from CVS
update_others()
{
  for d in ${BINUTILSDIR} ${GDBDIR} ${NEWLIBDIR}
  do
    
    cd ${d} 
    if [ -d .svn ] ; then
      echo "I do not update SVN for ${d}"
      exit 1
   fi
   if [ -d CVS ] ; then
     cvs up -P 2>&1 | grep -v ^cvs
   fi
  done
}

do_cpus()
{
  bsp=

  exitStatus=0
  for cpu in $*
  do
    case $cpu in
      arm)     bsp=edb7312      ;;
      avr)     bsp=avrtest      ;;
      bfin)    bsp=eZKit533     ;;
      h8300)   bsp=h8sim        ;;
      i386)    bsp=pc386        ;;
      lm32)    bsp=lm32_evr     ;;
      m32c)    bsp=m32csim      ;;
      m32r)    bsp=m32rsim      ;;
      m68k)    bsp=uC5282       ;;
      mips)    bsp=jmr3904      ;;
      powerpc) bsp=psim         ;;
      sh)      bsp=simsh1       ;;
      sparc)   bsp=sis          ;;
      *)
	echo "Unknown CPU ${cpu}"
	exit 1
	;;
    esac

    doOne=${SCRIPTDIR}/gcc/do_one 
    time sh -x ${doOne} -v -b -D -1 -d -r ${adaArg} ${mailArg} ${testArg} \
        ${cpu} ${bsp} >${BASEDIR}/${bsp}.log 2>&1
    echo $?
  done

  stopped=`date`
  echo Started at: ${start}
  echo Stopped at: ${stopped}
}

update_gcc

if [ ${doCleanInstallPoint} = "yes" ] ; then
  # Clean the install point
  clean_up
fi

# Update gcc and install autotools in parallel
  if [ ${doCleanInstallPoint} = "yes" ] ; then
    install_auto
  fi
  if [ ${doUpdateTools} = "yes" ] ; then
    update_gcc
    update_others
  fi
wait

# Do any remaining prep work in parallel
  if [ ${doUpdateRTEMS} = "yes" ] ; then
    update_rtems
  fi
wait

if [ ${doNative} = "yes" ]; then
  # Build the native compiler as a baseline to build the others
  time sh -x ${SCRIPTDIR}/gcc/do_one -n >${BASEDIR}/native.log 2>&1
fi

# Now cycle over all these CPUs
if [ $? -eq 0 ] ; then
  if [ $# -eq 0 ] ; then
    # Requires Skyeye install
    do_cpus arm

    # no simulator -- waiting for Skyeye
    do_cpus bfin m68k

    # Simulators included in gdb
    do_cpus h8300 lm32 m32c m32r mips powerpc sh sparc

    # Requires qemu installation
    do_cpus i386 m68k


    # port insufficient to run gcc tests
    do_cpus avr
  else
    for cpu in ${CPUs}
    do
      do_cpus ${cpu}
    done
  fi
  
fi

stopped=`date`
echo Started at: ${start}
echo Stopped at: ${stopped}
